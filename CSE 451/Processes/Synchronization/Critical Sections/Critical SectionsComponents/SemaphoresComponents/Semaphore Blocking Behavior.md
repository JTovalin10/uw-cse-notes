## Blocking
- Each semaphore has an associated queue of threads
	- when **P** is called by a thread
		- if sem was *available* (>0), decrement sem and let thread continue
		- if sem was *unavailable* (0), place thread on associated queue; run some other thread
	- when **V** is called by a thread
		- if thread(s) are waiting on associated queue, unblock one
			- place it on the ready queue
			- might as well let the "V-ing" thread continue execution
		- otherwise ( when no thread are waiting on the sem), increment sem
			- the signal is "remembered" for the next P is called
