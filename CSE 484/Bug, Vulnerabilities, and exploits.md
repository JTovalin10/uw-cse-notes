## Bugs

Software bugs can cause unseen and unexpected consequences that compromise program reliability and security.

Bugs become especially dangerous when attackers intentionally exploit them to:

- Gain unauthorized access
- Execute malicious code
- Crash systems
- Steal or corrupt data

One of the most common and serious exploitable bugs is the **buffer overflow**.

---

## Buffer Overflow

### What is a Buffer?

A **buffer** is a pre-defined data storage area allocated in computer memory, typically on the **stack** or **heap**. [[Memory Layout in a Program]]

Buffers are used to temporarily store data such as:

- User input
- Network packets
- File contents
- String data

### How Buffer Overflow Occurs

A buffer overflow happens when data written to a buffer **exceeds its allocated size**, causing it to overwrite adjacent memory locations.

#### The Problem: Missing Bounds Checking

```c
char buffer[8];          // Buffer can hold 8 bytes
strcpy(buffer, "Hello"); // OK - 5 bytes + null terminator
strcpy(buffer, "This is way too long!"); // OVERFLOW!
```

Without proper **bounds checking**, the program doesn't verify that incoming data fits within the buffer's capacity.

### Consequences of Buffer Overflow

#### 1. **Program Crash**

- Overwriting critical memory causes undefined behavior
- Can corrupt stack data structures
- May trigger segmentation faults

#### 2. **Attacker Exploitation**

- Attacker can overwrite adjacent stack locations with malicious data
- Can modify function return addresses
- Can inject and execute arbitrary code

---

## Buffer Overflow Attack Diagram

### Normal Stack Layout

```
High Addresses
    │
    v

┌──────────────────────┐
│  Return Address      │  ← Where to return after function
├──────────────────────┤
│  Saved Frame Pointer │
├──────────────────────┤
│  Local Variables     │
├──────────────────────┤
│  buffer[8]           │  ← Safe: data stays within bounds
│  [........]          │
└──────────────────────┘

    ↓
Low Addresses
```

### After Buffer Overflow Attack

```
High Addresses
    │
    v

┌──────────────────────┐
│  OVERWRITTEN!        │  ← Attacker overwrites return address
│  → Points to         │     to point to injected code
│     malicious code   │
├──────────────────────┤
│  OVERWRITTEN!        │  ← Frame pointer corrupted
├──────────────────────┤
│  OVERWRITTEN!        │  ← Local variables corrupted
├──────────────────────┤
│  buffer[8]           │
│  [AAAAAAAAAAAAAAAA...│  ← Overflow: data exceeds buffer
│   AAAAAAAAAAAAAAAA...│     and spills into adjacent memory
│   MALICIOUS_CODE]    │
└──────────────────────┘

    ↓
Low Addresses
```

### Attack Process

1. **Attacker identifies vulnerable buffer** - finds code without bounds checking
2. **Crafts malicious input** that exceeds buffer size
3. **Injects shellcode** - executable malicious code placed in the buffer
4. **Overwrites return address** - modifies it to point back to the injected shellcode
5. **Function returns** - instead of returning to legitimate code, execution jumps to attacker's code
6. **Attacker gains control** - malicious code executes with program's privileges

### Example Attack Scenario

```
Vulnerable code:
    void vulnerable_function(char *input) {
        char buffer[64];
        strcpy(buffer, input);  // No bounds checking!
    }

Attack input:
    [64 bytes of shellcode][overwritten data][new return address → shellcode]
    
Result:
    When function returns, it jumps to attacker's shellcode instead of 
    legitimate code, executing malicious commands
```

---

## Prevention Techniques

### 1. **Bounds Checking**

```c
// Unsafe
strcpy(buffer, input);

// Safe
strncpy(buffer, input, sizeof(buffer) - 1);
buffer[sizeof(buffer) - 1] = '\0';
```

### 2. **Use Safe Functions**

- Replace `strcpy()` with `strncpy()` or `strlcpy()`
- Replace `gets()` with `fgets()`
- Replace `sprintf()` with `snprintf()`

### 3. **Modern Protections**

- **Stack Canaries** - special values placed before return address to detect overwrites
- **ASLR (Address Space Layout Randomization)** - randomizes memory locations
- **DEP/NX (Data Execution Prevention)** - marks stack as non-executable
- **Compiler warnings** - enable `-Wall -Wextra` to catch unsafe code
- **Modern OS**: Only runs code in the text [[Memory Layout in a Program]]

### 4. **Memory-Safe Languages**

- Use languages with automatic bounds checking (Python, Java, Rust)
- These prevent buffer overflows at the language level
## off by one overflow
- overwrites the frame pointer
- 